<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Image RGB K-Means Clustering</title>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<style>
  body { font-family: Arial; text-align: center; }
  .container { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; }
  canvas { border: 1px solid #ccc; width: 400px; height: 400px; object-fit: contain; }
  #plot3d { width: 400px; height: 400px; }
</style>
</head>
<body>

<h2>Image RGB K-Means Clustering</h2>
<input type="file" id="upload" accept="image/*"><br><br>
<label>Number of Clusters (2â€“9): </label>
<input type="number" id="kValue" min="2" max="9" value="3">
<button id="processBtn">Process</button>

<div class="container">
  <div>
    <h3>Original Image</h3>
    <canvas id="originalCanvas"></canvas>
  </div>
  <div>
    <h3>RGB 3D Plot</h3>
    <div id="plot3d"></div>
  </div>
  <div>
    <h3>Clustered Image</h3>
    <canvas id="clusteredCanvas"></canvas>
  </div>
</div>

<script>
const upload = document.getElementById('upload');
const processBtn = document.getElementById('processBtn');
const kInput = document.getElementById('kValue');
const origCanvas = document.getElementById('originalCanvas');
const clusteredCanvas = document.getElementById('clusteredCanvas');
const origCtx = origCanvas.getContext('2d');
const clusteredCtx = clusteredCanvas.getContext('2d');
let imgData = null;
let workWidth, workHeight;

upload.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const img = new Image();
    img.onload = () => {
        // Display original image scaled to canvas size
        origCtx.clearRect(0, 0, origCanvas.width, origCanvas.height);
        origCtx.drawImage(img, 0, 0, origCanvas.width, origCanvas.height);

        // Downsample for processing
        const maxDim = 200;
        const scale = Math.min(maxDim / img.width, maxDim / img.height, 1);
        workWidth = Math.floor(img.width * scale);
        workHeight = Math.floor(img.height * scale);

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = workWidth;
        tempCanvas.height = workHeight;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(img, 0, 0, workWidth, workHeight);
        imgData = tempCtx.getImageData(0, 0, workWidth, workHeight);
    };
    img.src = URL.createObjectURL(file);
});

processBtn.addEventListener('click', () => {
    if (!imgData) return alert("Upload an image first!");
    const k = parseInt(kInput.value);
    if (k < 2 || k > 9) return alert("K must be between 2 and 9");

    const pixels = [];
    for (let i = 0; i < imgData.data.length; i += 4) {
        pixels.push([imgData.data[i], imgData.data[i+1], imgData.data[i+2]]);
    }

    const {centroids, assignments} = kmeans(pixels, k);

    // Plot RGB points
    const traces = [];
    for (let cluster = 0; cluster < k; cluster++) {
        const clusterPoints = pixels.filter((_, idx) => assignments[idx] === cluster);
        const r = clusterPoints.map(p => p[0]);
        const g = clusterPoints.map(p => p[1]);
        const b = clusterPoints.map(p => p[2]);
        traces.push({
            x: r, y: g, z: b,
            mode: 'markers',
            type: 'scatter3d',
            marker: { size: 2, color: `rgb(${centroids[cluster][0]},${centroids[cluster][1]},${centroids[cluster][2]})` },
            name: `Cluster ${cluster+1}`
        });
    }
    Plotly.newPlot('plot3d', traces, {scene:{xaxis:{title:'R'},yaxis:{title:'G'},zaxis:{title:'B'}}});

    // Create clustered image (scaled back to display size)
    const newImgData = new ImageData(workWidth, workHeight);
    for (let i = 0; i < pixels.length; i++) {
        const [r, g, b] = centroids[assignments[i]];
        const idx = i * 4;
        newImgData.data[idx] = r;
        newImgData.data[idx+1] = g;
        newImgData.data[idx+2] = b;
        newImgData.data[idx+3] = 255;
    }

    // Draw clustered image scaled to canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = workWidth;
    tempCanvas.height = workHeight;
    tempCanvas.getContext('2d').putImageData(newImgData, 0, 0);
    clusteredCtx.clearRect(0, 0, clusteredCanvas.width, clusteredCanvas.height);
    clusteredCtx.drawImage(tempCanvas, 0, 0, clusteredCanvas.width, clusteredCanvas.height);
});

// Simple K-means
function kmeans(data, k, maxIter=10) {
    const centroids = [];
    for (let i = 0; i < k; i++) {
        centroids.push(data[Math.floor(Math.random() * data.length)].slice());
    }
    let assignments = new Array(data.length).fill(0);

    for (let iter = 0; iter < maxIter; iter++) {
        assignments = data.map(p => {
            let minDist = Infinity, cluster = 0;
            for (let c = 0; c < k; c++) {
                const dist = (p[0]-centroids[c][0])**2 + (p[1]-centroids[c][1])**2 + (p[2]-centroids[c][2])**2;
                if (dist < minDist) { minDist = dist; cluster = c; }
            }
            return cluster;
        });

        const sums = Array.from({length:k}, () => [0,0,0,0]);
        data.forEach((p, idx) => {
            const c = assignments[idx];
            sums[c][0] += p[0];
            sums[c][1] += p[1];
            sums[c][2] += p[2];
            sums[c][3] += 1;
        });
        for (let c = 0; c < k; c++) {
            if (sums[c][3] > 0) {
                centroids[c][0] = Math.round(sums[c][0] / sums[c][3]);
                centroids[c][1] = Math.round(sums[c][1] / sums[c][3]);
                centroids[c][2] = Math.round(sums[c][2] / sums[c][3]);
            }
        }
    }
    return {centroids, assignments};
}
</script>

</body>
</html>
